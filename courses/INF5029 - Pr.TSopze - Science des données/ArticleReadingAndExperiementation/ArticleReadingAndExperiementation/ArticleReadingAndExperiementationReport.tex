\documentclass[12pt,a4paper]{article}
\usepackage{pgf}
% \usepackage[condensed,math]{kurier}
\usepackage[T1]{fontenc}
\usepackage{svg}
%\usepackage[french]{babel}
\usepackage{tikz}
\usepackage{stanli}
\usepackage{afterpage}
\usepackage{multirow}
%\usepackage{subfig}
\usepackage{pgfpages}
\usepackage{pdfpages}
\usepackage{svg}
\usepackage{rotating}
\usepackage{multicol}
\usepackage[utf8]{inputenc}
\usepackage{translator}
\usepackage{float}
\usepackage{subfigure}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{acronym}
% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}
% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage[colorlinks=true, allcolors=black]{hyperref}
\usepackage{tikz}
\usetikzlibrary{positioning}
% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=1.5cm,left=1.5cm,right=1.5cm,marginparwidth=1.75cm]{geometry}
\usepackage{fancyhdr}
% modules




\title{}
\author{}
\date{}

%Sets the margins

\textwidth = 7.5 in
\textheight = 9.5 in
\oddsidemargin = -0.7 in
\evensidemargin = -0.3 in
\topmargin = -0.3 in
\headheight = 0.0 in
\headsep = 0.0 in
\parskip = 0.1in
\parindent = 0.0in

% Define the boxed layout
\pgfpagesdeclarelayout{boxed}
{
    \edef\pgfpageoptionborder{0pt}
}
{
    \pgfpagesphysicalpageoptions
    {%
        logical pages=1,%
    }
    \pgfpageslogicalpageoptions{1}
    {
        border code={},%
        border shrink=\pgfpageoptionborder,%
        resized width=.9\pgfphysicalwidth,%
        resized height=.9\pgfphysicalheight,%
        center=\pgfpoint{.5\pgfphysicalwidth}{.5\pgfphysicalheight}%
    }%
}

\fancypagestyle{firstpage}{
	\fancyhf{} % Clear header and footer
	\renewcommand{\headrulewidth}{0pt} % Remove header rule
	\renewcommand{\footrulewidth}{0pt} % Remove footer rule
	\fancyfoot[C]{} % Remove page number in the center
}
\begin{document}
\pgfpagesuselayout{boxed}
%\thispagestyle{firstpage}
\includepdf[pages=1, scale=1.1]{guard/guardPageReport.pdf}  % Include only page 1
\newpage
\tableofcontents

\pagebreak

% Définition des acronymes
\acrodef{IA}{Intelligence Artificielle}
\acrodef{AA}{Apprentissage Automatique}
\acrodef{ML}{Machine Learning}
\acrodef{ANN}{Artificial Neural Network}
\acrodef{RNN}{Recurrent Neural Network}
\acrodef{LSTM}{Long Short-Term Memory}
\acrodef{DT}{Decision Tree}
\acrodef{LR}{Logistic Regression}
\acrodef{XGB}{eXtreme Gradient Boosting}
\acrodef{SVM}{Support Vector Machine}
\acrodef{RF}{Random Forest}
\acrodef{LGBM}{Light Gradient boosting algorithm}

% introduction générale
{\center {\Huge \textbf{Définition des mots clés}}}
\begin{itemize}
\item \textbf{Le Machine Learning (apprentissage automatique)}\cite{wiki:MachineLearning} : est une branche de l'\ac{IA} qui se concentre sur le développement de techniques permettant aux ordinateurs d'apprendre à partir de données et d'améliorer leurs performances sans être explicitement programmés. Le Machine Learning repose sur des algorithmes et des modèles statistiques qui permettent aux machines de reconnaître des schémas, de prendre des décisions et de faire des prédictions basées sur les données d'entrée. Il est utilisé dans de nombreux domaines, tels que la reconnaissance vocale, la vision par ordinateur, l'analyse prédictive et la recommandation personnalisée.
\item \textbf{Le Software Testing (test logiciel)}\cite{wiki:SoftwareTesting} : est un processus d'évaluation systématique d'un logiciel afin de détecter les défauts, les erreurs et les incohérences qui pourraient affecter son bon fonctionnement. L'objectif du test logiciel est de s'assurer que le logiciel répond aux exigences spécifiées, de vérifier sa fonctionnalité, sa fiabilité, sa sécurité et sa performance. Le test logiciel peut inclure des activités telles que la création de cas de test, l'exécution de tests, la vérification des résultats et la documentation des problèmes identifiés.
\item \textbf{La Test Case Prioritization (hiérarchisation des cas de test)}\cite{yoo2019test} : est une technique utilisée pour ordonner les cas de test en fonction de leur importance et de leur criticité. L'objectif est de déterminer l'ordre d'exécution optimal des cas de test afin de maximiser l'efficacité du processus de test. La hiérarchisation des cas de test peut se baser sur différents critères, tels que l'impact commercial, la criticité des fonctionnalités, la probabilité d'échec, les exigences spécifiques, etc.
\item \textbf{La Test Case Selection (sélection des cas de test)}\cite{yoo2016test} : est le processus de choix des cas de test les plus pertinents et les plus appropriés pour être exécutés lors d'une campagne de test. La sélection des cas de test peut être basée sur différents critères, tels que la couverture des fonctionnalités, la complexité du code, les risques identifiés, les modifications récentes, etc. L'objectif est d'optimiser les ressources disponibles en se concentrant sur les cas de test qui sont les plus susceptibles de détecter des erreurs ou des défauts.
\item \textbf{La Continuous Integration (intégration continue)}\cite{wiki:ContinuousIntegration} : est une pratique de développement logiciel qui consiste à intégrer régulièrement les modifications de code réalisées par les membres d'une équipe de développement dans un dépôt centralisé. L'intégration continue est souvent associée à des processus d'automatisation tels que la compilation, les tests unitaires et l'analyse de code, qui sont déclenchés à chaque modification de code. L'objectif est de détecter rapidement les conflits, les erreurs et les incompatibilités, et de permettre une collaboration harmonieuse entre les développeurs.
\item \textbf{Un Build} : fait référence à la construction automatique et à la compilation du code source d'une application logicielle, généralement dans le cadre d'un processus d'intégration continue (CI - Continuous Integration). Le build est une étape essentielle dans le cycle de vie du développement logiciel, car il permet de transformer le code source en un exécutable ou un artefact qui peut être déployé et testé.
\end{itemize}
\newpage

%\section{Introduction}
%\label{sec:int}

\section{Context}
Le Genie logiciel pendant cette dernière décennie  a connut des améliorations fulgurantes qui visent à faciliter la vie des développeurs et opérationnels. L'Intégration continue est l'une des clés de ces améliorations qui consiste á automatiser la chaine de procédés de fusion des changements (modules ou patches) dans la chaine logicielle tout en garantissant la non regression du logiciel en question. Ainsi, pour assurer cette non régression du logiciel plusieurs tests sont effectués de manière automatique pendant cette étape afin de vérifier la fiabilité des nouveaux changements. Ces test de regression deviennent donc de plus en plus vaste et complexes ce qui entraine notamment la mauvaise qualité des builds intégrés ainsi que le retard dans le déploiement et la livraison des produits logiciels d'où la problématique d'optimiser le temps et la qualité des tests pour pallier à ces problèmes. 

En parallèle, avec l'évolution de la science des donnés notamment le \ac{ML}, d'autres optiques s'ouvrent pour pallier aux problèmes des tests de regression en Génie Logiciel. 

\section{Limites des solutions existantes}
C'est ainsi que de nombreuses recherches ont fait usage des algorithmes de machine learning dans la prioritisation des cas de test dans un processus d'intégration continue. Ses derniers avaient comme limites d'être extrêmement coûteux en temps et en ressources de calcul pour les meilleurs.

\section{Problème}
Comment optimiser la prioritisation des cas de tests dans un processus d'intégration continue (IC) en utilisant des techniques basées sur l'apprentissage automatique (AA)?

%Nous commençons par présenter dans la section~\ref{sec:sp} la solution proposé par Ahmadreza Saboor Yaraghi et al\cite{yaraghi2022scalable}. Ensuite, dans la section~\ref{sec:as} nous présentons les avantages de leur méthodologie. Puis, dans la section~\ref{sec:lp} nous ressortons les limites de leur méthodologie. Et enfin, dans la section~\ref{sec:re} nous présentons leurs résultats expérimentaux (données, métriques d'évaluation et résultats.
 
 \section{Solution Proposé (Méthodologie)}
 \label{sec:sp}
 
 
 
 \section{Avantage de la solution proposé}
  \label{sec:as}
 
\section{Limites de cette proposition}
 \label{sec:lp}

\section{Résultats expérimentaux (données, métriques d'évaluation, résultats)}
 \label{sec:re}


% reférence
\newpage
\bibliographystyle{IEEEtran}
\bibliography{sample}
\nocite{*}

\end{document}
